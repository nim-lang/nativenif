# Generated by tools/gen_instructions.nim from doc/nj.md. DO NOT EDIT!

import tags

type
  NjExpr* = enum
    NoExpr
    AtX = (ord(AtTagId), "at")  ## array indexing operation
    DerefX = (ord(DerefTagId), "deref")  ## pointer deref operation
    DotX = (ord(DotTagId), "dot")  ## object field selection
    PatX = (ord(PatTagId), "pat")  ## pointer indexing operation
    ParX = (ord(ParTagId), "par")  ## syntactic parenthesis
    AddrX = (ord(AddrTagId), "addr")  ## address of operation
    NilX = (ord(NilTagId), "nil")  ## nil pointer value
    InfX = (ord(InfTagId), "inf")  ## positive infinity floating point value
    NeginfX = (ord(NeginfTagId), "neginf")  ## negative infinity floating point value
    NanX = (ord(NanTagId), "nan")  ## NaN floating point value
    FalseX = (ord(FalseTagId), "false")  ## boolean `false` value
    TrueX = (ord(TrueTagId), "true")  ## boolean `true` value
    NotX = (ord(NotTagId), "not")  ## boolean `not` operation
    NegX = (ord(NegTagId), "neg")  ## negation operation
    SizeofX = (ord(SizeofTagId), "sizeof")  ## `sizeof` operation
    AlignofX = (ord(AlignofTagId), "alignof")  ## `alignof` operation
    OffsetofX = (ord(OffsetofTagId), "offsetof")  ## `offsetof` operation
    OconstrX = (ord(OconstrTagId), "oconstr")  ## object constructor
    AconstrX = (ord(AconstrTagId), "aconstr")  ## array constructor
    OvfX = (ord(OvfTagId), "ovf")  ## access overflow flag
    AddX = (ord(AddTagId), "add")
    SubX = (ord(SubTagId), "sub")
    MulX = (ord(MulTagId), "mul")
    DivX = (ord(DivTagId), "div")
    ModX = (ord(ModTagId), "mod")
    ShrX = (ord(ShrTagId), "shr")
    ShlX = (ord(ShlTagId), "shl")
    BitandX = (ord(BitandTagId), "bitand")
    BitorX = (ord(BitorTagId), "bitor")
    BitxorX = (ord(BitxorTagId), "bitxor")
    BitnotX = (ord(BitnotTagId), "bitnot")
    EqX = (ord(EqTagId), "eq")
    NeqX = (ord(NeqTagId), "neq")
    LeX = (ord(LeTagId), "le")
    LtX = (ord(LtTagId), "lt")
    CastX = (ord(CastTagId), "cast")  ## `cast` operation
    ConvX = (ord(ConvTagId), "conv")  ## type conversion
    VX = (ord(VTagId), "v")  ## `versioned` locations
    AshrX = (ord(AshrTagId), "ashr")
    BaseobjX = (ord(BaseobjTagId), "baseobj")  ## object conversion to base type

proc rawTagIsNjExpr*(raw: TagEnum): bool {.inline.} =
  raw in {AtTagId, DerefTagId, DotTagId, PatTagId, ParTagId, AddrTagId, NilTagId, InfTagId, NeginfTagId, NanTagId, FalseTagId, TrueTagId, NotTagId, NegTagId, SizeofTagId, AlignofTagId, OffsetofTagId, OconstrTagId, AconstrTagId, OvfTagId, AddTagId, SubTagId, MulTagId, DivTagId, ModTagId, ShrTagId, ShlTagId, BitandTagId, BitorTagId, BitxorTagId, BitnotTagId, EqTagId, NeqTagId, LeTagId, LtTagId, CastTagId, ConvTagId, VTagId, AshrTagId, BaseobjTagId}

type
  NjStmt* = enum
    NoStmt
    CallS = (ord(CallTagId), "call")  ## call operation
    GvarS = (ord(GvarTagId), "gvar")  ## global variable declaration
    TvarS = (ord(TvarTagId), "tvar")  ## thread local variable declaration
    VarS = (ord(VarTagId), "var")  ## variable declaration
    ConstS = (ord(ConstTagId), "const")  ## const variable declaration
    ResultS = (ord(ResultTagId), "result")  ## result variable declaration
    ProcS = (ord(ProcTagId), "proc")  ## proc declaration
    TypeS = (ord(TypeTagId), "type")  ## type declaration
    StoreS = (ord(StoreTagId), "store")  ## `asgn` with reversed operands that reflects evaluation order
    KeepovfS = (ord(KeepovfTagId), "keepovf")  ## keep overflow flag statement
    StmtsS = (ord(StmtsTagId), "stmts")  ## list of statements
    IteS = (ord(IteTagId), "ite")  ## if-then-else followed by optional `join` information
    ItecS = (ord(ItecTagId), "itec")  ## if-then-else (that was a `case`)
    LoopS = (ord(LoopTagId), "loop")  ## `loop` components are (before-cond, cond, loop-body, after)
    UnknownS = (ord(UnknownTagId), "unknown")  ## location's contents is unknown at this point
    JtrueS = (ord(JtrueTagId), "jtrue")  ## set variables v1, v2, ... to `(true)`; hint this should become a jump
    CfvarS = (ord(CfvarTagId), "cfvar")  ## declare a new control flow variable `D` of type `bool` initialized to `false`
    KillS = (ord(KillTagId), "kill")  ## some.var is about to disappear (scope exit)
    AssumeS = (ord(AssumeTagId), "assume")  ## `assume` pragma/annotation
    AssertS = (ord(AssertTagId), "assert")  ## `assert` pragma/annotation
    AsmS = (ord(AsmTagId), "asm")  ## `asm` statement

proc rawTagIsNjStmt*(raw: TagEnum): bool {.inline.} =
  raw in {CallTagId, GvarTagId, TvarTagId, VarTagId, ConstTagId, ResultTagId, ProcTagId, TypeTagId, StoreTagId, KeepovfTagId, StmtsTagId, IteTagId, ItecTagId, LoopTagId, UnknownTagId, JtrueTagId, CfvarTagId, KillTagId, AssumeTagId, AssertTagId, AsmTagId}

type
  NjType* = enum
    NoType
    UnionT = (ord(UnionTagId), "union")  ## first one is Nifc union declaration, second one is Nimony union pragma
    ObjectT = (ord(ObjectTagId), "object")  ## object type declaration
    ProctypeT = (ord(ProctypeTagId), "proctype")  ## proc type declaration
    IT = (ord(ITagId), "i")  ## `int` builtin type
    UT = (ord(UTagId), "u")  ## `uint` builtin type
    FT = (ord(FTagId), "f")  ## `float` builtin type
    CT = (ord(CTagId), "c")  ## `char` builtin type
    BoolT = (ord(BoolTagId), "bool")  ## `bool` builtin type
    PtrT = (ord(PtrTagId), "ptr")  ## `ptr` type contructor
    ArrayT = (ord(ArrayTagId), "array")  ## `array` type constructor
    FlexarrayT = (ord(FlexarrayTagId), "flexarray")  ## `flexarray` type constructor
    AptrT = (ord(AptrTagId), "aptr")  ## "pointer to array of" type constructor
    PointerT = (ord(PointerTagId), "pointer")  ## `pointer` type

proc rawTagIsNjType*(raw: TagEnum): bool {.inline.} =
  raw in {UnionTagId, ObjectTagId, ProctypeTagId, ITagId, UTagId, FTagId, CTagId, BoolTagId, PtrTagId, ArrayTagId, FlexarrayTagId, AptrTagId, PointerTagId}

type
  NjOther* = enum
    NoOther
    NotnilU = (ord(NotnilTagId), "notnil")  ## `not nil` pointer annotation
    KvU = (ord(KvTagId), "kv")  ## key-value pair
    VvU = (ord(VvTagId), "vv")  ## value-value pair (used for explicitly named arguments in function calls)
    ParamU = (ord(ParamTagId), "param")  ## parameter declaration
    FldU = (ord(FldTagId), "fld")  ## field declaration
    ParamsU = (ord(ParamsTagId), "params")  ## list of proc parameters, also used as a "proc type"
    JoinU = (ord(JoinTagId), "join")  ## `join` construct inside `ite`

proc rawTagIsNjOther*(raw: TagEnum): bool {.inline.} =
  raw in {NotnilTagId, KvTagId, VvTagId, ParamTagId, FldTagId, ParamsTagId, JoinTagId}

type
  NjTypeQualifier* = enum
    NoQual
    AtomicQ = (ord(AtomicTagId), "atomic")  ## `atomic` type qualifier for NIFC
    RoQ = (ord(RoTagId), "ro")  ## `readonly` (= `const`) type qualifier for NIFC
    RestrictQ = (ord(RestrictTagId), "restrict")  ## type qualifier for NIFC
    CpprefQ = (ord(CpprefTagId), "cppref")  ## type qualifier for NIFC that provides a C++ reference

proc rawTagIsNjTypeQualifier*(raw: TagEnum): bool {.inline.} =
  raw >= AtomicTagId and raw <= CpprefTagId

type
  NjPragma* = enum
    NoPragma
    InlineP = (ord(InlineTagId), "inline")  ## `inline` proc annotation
    NoinlineP = (ord(NoinlineTagId), "noinline")  ## `noinline` proc annotation
    VarargsP = (ord(VarargsTagId), "varargs")  ## `varargs` proc annotation
    WasP = (ord(WasTagId), "was")
    AlignP = (ord(AlignTagId), "align")
    BitsP = (ord(BitsTagId), "bits")
    DynlibP = (ord(DynlibTagId), "dynlib")  ## `dynlib` pragma
    ExportcP = (ord(ExportcTagId), "exportc")  ## `exportc` pragma
    ThreadvarP = (ord(ThreadvarTagId), "threadvar")  ## `threadvar` pragma
    NoreturnP = (ord(NoreturnTagId), "noreturn")  ## `noreturn` pragma
    NoinitP = (ord(NoinitTagId), "noinit")  ## `noinit` pragma
    RequiresP = (ord(RequiresTagId), "requires")  ## `requires` pragma
    EnsuresP = (ord(EnsuresTagId), "ensures")  ## `ensures` pragma
    PackedP = (ord(PackedTagId), "packed")  ## `packed` pragma

proc rawTagIsNjPragma*(raw: TagEnum): bool {.inline.} =
  raw in {InlineTagId, NoinlineTagId, VarargsTagId, WasTagId, AlignTagId, BitsTagId, DynlibTagId, ExportcTagId, ThreadvarTagId, NoreturnTagId, NoinitTagId, RequiresTagId, EnsuresTagId, PackedTagId}

type
  CallConv* = enum
    NoCallConv
    CdeclC = (ord(CdeclTagId), "cdecl")  ## `cdecl` calling convention
    StdcallC = (ord(StdcallTagId), "stdcall")  ## `stdcall` calling convention
    SafecallC = (ord(SafecallTagId), "safecall")  ## `safecall` calling convention
    SyscallC = (ord(SyscallTagId), "syscall")  ## `syscall` calling convention
    FastcallC = (ord(FastcallTagId), "fastcall")  ## `fastcall` calling convention
    ThiscallC = (ord(ThiscallTagId), "thiscall")  ## `thiscall` calling convention
    NoconvC = (ord(NoconvTagId), "noconv")  ## no explicit calling convention
    MemberC = (ord(MemberTagId), "member")  ## `member` calling convention
    NimcallC = (ord(NimcallTagId), "nimcall")  ## `nimcall` calling convention

proc rawTagIsCallConv*(raw: TagEnum): bool {.inline.} =
  raw >= CdeclTagId and raw <= NimcallTagId

