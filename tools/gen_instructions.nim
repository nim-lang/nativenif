## This tool generates the different enums from the doc/instructions.md file.

import std / [strutils, sets, os]

proc toNimName(s: string; suffix: string): string =
  s[0].toUpperAscii & s.substr(1) & suffix

type
  EnumList = enum
    X64Inst, A64Inst, NifasmType, NifasmDecl, NifasmExpr, X64Flag, X64Reg, A64Reg

proc toSuffix(e: EnumList): (string, string) =
  case e
  of X64Inst: ("X64", "NoX64Inst")
  of A64Inst: ("A64", "NoA64Inst")
  of NifasmType: ("T", "NoType")
  of NifasmDecl: ("D", "NoDecl")
  of NifasmExpr: ("X", "NoExpr")
  of X64Flag: ("O", "NoFlag")
  of X64Reg: ("R", "NoReg")
  of A64Reg: ("R", "NoReg")

proc shortcutToEnumList(shortcut: string): EnumList =
  try:
    result = parseEnum[EnumList](shortcut.strip())
  except ValueError:
    quit "unknown enum type: " & shortcut

const
  Header = "# Generated by tools/gen_tags.nim from doc/instructions.md. DO NOT EDIT!\n"

type
  EnumField = object
    name: string
    tag: string
    value: int
    desc: string
  EnumImpls = array[EnumList, seq[EnumField]]

proc writeClassifier(f: File; e: EnumList; fields: seq[EnumField]) =
  var first = ""
  var last = ""
  var prev = -1
  var holes: seq[int] = @[]
  for f in fields:
    if first.len == 0: first = f.tag
    last = f.tag
    if prev >= 0 and f.value != prev + 1:
      for h in prev + 1..f.value - 1:
        holes.add h
    prev = f.value
  f.write "\n\nproc rawTagIs" & $e & "*(raw: TagEnum): bool {.inline.} ="
  if holes.len <= 3:
    f.write "\n  raw >= " & toNimName(first, "TagId") & " and raw <= " & toNimName(last, "TagId")
    for h in holes:
      f.write " and raw != TagEnum(" & $h & ")"
    f.write "\n"
  else:
    f.write "\n  raw in {"
    var i = 0
    for field in fields:
      if i > 0: f.write ", "
      f.write toNimName(field.tag, "TagId")
      inc i
    f.write "}\n"

proc writeModel(basename: string; data: EnumImpls; first, last: EnumList) =
  let f = open(basename, fmWrite)
  f.writeLine Header
  f.writeLine "import instructions"
  for e in first..last:
    f.write "\ntype"
    f.write "\n  " & $e & "* = enum"
    f.write "\n    " & toSuffix(e)[1]
    for field in data[e]:
      f.write "\n    " & field.name
      f.write " = (ord(" & toNimName(field.tag, "TagId") & "), " & escape(field.tag) & ")"
      if field.desc.len > 0:
        f.write "  ## " & field.desc
    writeClassifier(f, e, data[e])
  f.write "\n"
  f.close()

proc writeTagsFile(output: string; data: seq[(string, int)]) =
  let f = open(output, fmWrite)
  f.writeLine Header
  f.writeLine "type\n  TagEnum* = enum"
  f.writeLine "    InvalidTagId"
  for d in data:
    f.writeLine "    " & toNimName(d[0], "TagId")
  f.writeLine "const"
  f.writeLine "  TagData*: array[TagEnum, (string, int)] = ["
  f.write "    (" & escape("InvalidTagId") & ", 0)"
  for d in data:
    f.write ",\n"
    f.write "    (" & escape(d[0]) & ", " & $d[1] & ")"
  f.writeLine "\n  ]"
  f.close()

proc extractTagName(s: string): string =
  var i = 0
  while i < s.len and s[i] == ' ': inc i
  if i < s.len and s[i] == '`': inc i
  if i < s.len and s[i] == '(': inc i
  if i < s.len and s[i] in IdentStartChars:
    let start = i
    while i < s.len and s[i] in IdentChars:
      inc i
    result = s.substr(start, i - 1)
  else:
    quit "Cannot extract tag name from: " & s

proc genTags(inp: File) =
  var i = -2
  var enumDecls = default EnumImpls
  var tags: seq[(string, int)] = @[]
  var knownTags = initHashSet[string]()
  for line in lines(inp):
    inc i
    if i <= 0: continue # skip header
    if line.strip().len == 0: continue
    var parts = line.split("|")
    if parts.len == 0: continue
    if parts.len < 5:
      quit "WRONG LINE: " & line
    let tagName = extractTagName parts[1]
    if knownTags.containsOrIncl(tagName):
      quit "DUPLICATE TAG: " & tagName
    tags.add (tagName, i)

    let desc = parts[3].strip()
    let affectedEnums = parts[2].split(",")
    assert affectedEnums.len > 0
    for a in affectedEnums:
      let e = shortcutToEnumList(a)
      enumDecls[e].add EnumField(
        name: toNimName(tagName, toSuffix(e)[0]),
        tag: tagName,
        value: i,
        desc: desc
      )

  createDir "src/nifasm"
  writeTagsFile "src/nifasm/instructions.nim", tags
  # writeModel "src/nifasm/nifasm_model.nim", enumDecls, X64Inst, X64Flag
  # For now I'll just rely on instructions.nim and manual casting or validation if needed,
  # or I can generate the model file if I decide to use it.
  # Let's generate the model file too, it's useful.

  writeModel "src/nifasm/model.nim", enumDecls, X64Inst, A64Reg

proc main =
  var inp = open("doc/instructions.md", fmRead)
  genTags(inp)
  inp.close()

main()

